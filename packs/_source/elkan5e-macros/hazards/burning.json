{
	"name": "Burning",
	"type": "script",
	"_id": "g6P9Rkg63Rz74KNe",
	"author": "71r7qVMKZkbQ86li",
	"img": "modules/elkan5e/icons/hazards/burning.svg",
	"scope": "global",
	"command": "(async () => {\n  const DEFAULT_FORMULA = \"1d8\";\n  const DAMAGE_TYPE = \"fire\";\n\n  const _args = globalThis.args ?? [];\n  const lastArg = _args.at(-1) ?? {};\n\n  /* -------------------------------------------- */\n  /* Token Resolution (robust, context-agnostic)  */\n  /* -------------------------------------------- */\n  const resolveToken = async () => {\n    // 1) Midi args\n    const id = lastArg.tokenId ?? lastArg.token?.id;\n    if (id) return canvas.tokens.get(id) ?? null;\n\n    if (lastArg.tokenUuid) {\n      try {\n        const doc = await fromUuid(lastArg.tokenUuid);\n        if (doc?.object) return doc.object;\n      } catch {}\n    }\n\n    if (lastArg.token) return lastArg.token.object ?? lastArg.token;\n\n    // 2) Selected token\n    if (canvas.tokens.controlled.length) return canvas.tokens.controlled[0];\n\n    // 3) Chat speaker token\n    const speaker = ChatMessage.getSpeaker();\n    if (speaker?.token) {\n      const t = canvas.tokens.get(speaker.token);\n      if (t) return t;\n    }\n\n    // 4) User character token\n    const char = game.user?.character;\n    if (char) {\n      const t = canvas.tokens.placeables.find(pt => pt.actor?.id === char.id);\n      if (t) return t;\n    }\n\n    return null;\n  };\n\n  const token = await resolveToken();\n  if (!token) {\n    ui.notifications.error(\"Burning: No token context found.\");\n    return {};\n  }\n\n  const actor = token.actor;\n  if (!actor) return {};\n\n  /* -------------------------------------------- */\n  /* Read & Validate Burning Formula              */\n  /* -------------------------------------------- */\n  const tokenDoc = token.document ?? token;\n\n  const actorBurning = actor.getFlag ? await actor.getFlag(\"elkan5e\", \"burning\") : null;\n  const tokenBurning = tokenDoc?.getFlag ? await tokenDoc.getFlag(\"elkan5e\", \"burning\") : null;\n\n  let formula = String(actorBurning ?? tokenBurning ?? \"\").trim() || DEFAULT_FORMULA;\n  if (Roll.validate && !Roll.validate(formula)) formula = DEFAULT_FORMULA;\n\n  const roll = await (new Roll(formula)).evaluate({ async: true });\n  const total = Number(roll.total ?? 0);\n  if (!total) return {};\n\n  /* -------------------------------------------- */\n  /* MIDIQOL PATH                                 */\n  /* -------------------------------------------- */\n  if (game.modules.get(\"midi-qol\")?.active && globalThis.MidiQOL?.DamageOnlyWorkflow) {\n    await new MidiQOL.DamageOnlyWorkflow(\n      actor,\n      token,\n      total,\n      DAMAGE_TYPE,\n      [token],          // MUST be array\n      roll,             // Roll object required\n      {\n        flavor: `Burning (${formula}) [${DAMAGE_TYPE}]`,\n        useOther: true,\n      }\n    );\n    return {};\n  }\n\n  /* -------------------------------------------- */\n  /* FALLBACK: Direct HP Subtraction              */\n  /* -------------------------------------------- */\n  const hpPath = \"system.attributes.hp.value\";\n  const hp = foundry.utils.getProperty(actor, hpPath);\n\n  if (typeof hp !== \"number\") {\n    ui.notifications.error(\"Burning: Could not read HP.\");\n    return {};\n  }\n\n  await actor.update({ [hpPath]: Math.max(0, hp - total) });\n\n  ChatMessage.create({\n    speaker: ChatMessage.getSpeaker({ token }),\n    content: `<p><b>${token.name}</b> takes <b>${total}</b> fire damage (burning).</p>`,\n  });\n\n  return {};\n})();",
	"folder": "Z0WbSeZ2agJTALHX",
	"_key": "!macros!g6P9Rkg63Rz74KNe"
}