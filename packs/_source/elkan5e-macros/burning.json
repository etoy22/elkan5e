{
	"name": "Burning",
	"type": "script",
	"_id": "g6P9Rkg63Rz74KNe",
	"author": "71r7qVMKZkbQ86li",
	"img": "modules/elkan5e/icons/hazards/burning.svg",
	"scope": "global",
	"command": "(async () => {\n  const DEFAULT_FORMULA = \"1d8\";\n  const DAMAGE_TYPE = \"fire\";\n\n  const _args = globalThis.args ?? [];\n  const lastArg = _args.at(-1) ?? {};\n\n  const resolveToken = async () => {\n    // A) Midi-style args\n    const id = lastArg.tokenId ?? lastArg.token?.id;\n    if (id) {\n      const t = canvas?.tokens?.get(id);\n      if (t) return t;\n    }\n\n    if (lastArg.tokenUuid) {\n      try {\n        const doc = await fromUuid(lastArg.tokenUuid);\n        if (doc?.object) return doc.object; // TokenDocument => placeable\n      } catch (e) {}\n    }\n\n    if (lastArg.token) return lastArg.token.object ?? lastArg.token;\n\n    // B) Selected token\n    const controlled = canvas?.tokens?.controlled?.[0];\n    if (controlled) return controlled;\n\n    // C) Chat speaker token (very common when macro run from hotbar)\n    const speaker = ChatMessage.getSpeaker();\n    if (speaker?.token) {\n      const t = canvas?.tokens?.get(speaker.token);\n      if (t) return t;\n    }\n\n    // D) User's assigned character token on this scene\n    const char = game.user?.character;\n    if (char) {\n      const t = canvas?.tokens?.placeables?.find(pt => pt.actor?.id === char.id);\n      if (t) return t;\n    }\n\n    // E) Last resort: first token you own\n    const owned = canvas?.tokens?.placeables?.find(pt => pt.document?.isOwner);\n    if (owned) return owned;\n\n    return null;\n  };\n\n  const token = await resolveToken();\n  if (!token) {\n    ui.notifications.error(\"No token context: select a token or run from a Midi OnUse macro that provides args.\");\n    console.warn(\"No token context\", { args: _args, lastArg });\n    return {};\n  }\n\n  // Actor: prefer token.actor; else actorUuid if available\n  let actor = token.actor ?? null;\n  if (!actor && lastArg.actorUuid) {\n    const a = await fromUuid(lastArg.actorUuid);\n    actor = a?.actor ?? a ?? null;\n  }\n  if (!actor) return ui.notifications.warn(\"No actor found for resolved token.\");\n\n  // Flag formula (actor preferred, then token)\n  const tokenDoc = token.document ?? token;\n  const actorBurning = actor.getFlag ? await actor.getFlag(\"elkan5e\", \"burning\") : actor?.flags?.elkan5e?.burning;\n  const tokenBurning = tokenDoc?.getFlag ? await tokenDoc.getFlag(\"elkan5e\", \"burning\") : tokenDoc?.flags?.elkan5e?.burning;\n\n  const raw = String(actorBurning ?? tokenBurning ?? \"\").trim();\n  let formula = raw || DEFAULT_FORMULA;\n  if (Roll.validate && !Roll.validate(formula)) formula = DEFAULT_FORMULA;\n\n  const damageRoll = await (new Roll(formula)).evaluate({ async: true });\n  const total = Number(damageRoll.total ?? 0);\n  if (!total) return {};\n\n  const featureName =\n    lastArg?.workflow?.item?.name ??\n    lastArg?.item?.name ??\n    \"Burning\";\n\n  // IMPORTANT: array of targets\n  const targets = [token];\n\n  await new MidiQOL.DamageOnlyWorkflow(\n    actor,\n    token,\n    total,\n    DAMAGE_TYPE,\n    targets,\n    damageRoll,\n    {\n      flavor: `${featureName} (${formula}) [${DAMAGE_TYPE}]`,\n      itemCardId: lastArg?.itemCardId,\n      useOther: true,\n    }\n  );\n\n  return {};\n})();",
	"folder": null,
	"_key": "!macros!g6P9Rkg63Rz74KNe"
}